{
  "timestamp": "20250917_215443",
  "run_date": "2025-09-17T21:54:43.025087",
  "config": {
    "environment": "development",
    "max_stories": 5,
    "tts_voice": "en-US-Neural2-D"
  },
  "stories": [
    {
      "id": 45283887,
      "title": "Slack has raised our charges by $195k per year",
      "url": "https://skyfall.dev/posts/slack",
      "score": 846,
      "by": "JustSkyfall",
      "time": 1758159431,
      "descendants": 415,
      "type": "story",
      "created_at": "2025-09-17T15:37:11"
    },
    {
      "id": 45283306,
      "title": "Meta Ray-Ban Display",
      "url": "https://www.meta.com/blog/meta-ray-ban-display-ai-glasses-connect-2025/",
      "score": 350,
      "by": "martpie",
      "time": 1758155444,
      "descendants": 488,
      "type": "story",
      "created_at": "2025-09-17T14:30:44"
    },
    {
      "id": 45279384,
      "title": "WASM 3.0 Completed",
      "url": "https://webassembly.org/news/2025-09-17-wasm-3.0/",
      "score": 836,
      "by": "todsacerdoti",
      "time": 1758133013,
      "descendants": 340,
      "type": "story",
      "created_at": "2025-09-17T08:16:53"
    },
    {
      "id": 45284311,
      "title": "Show HN: The text disappears when you screenshot it",
      "url": "https://unscreenshottable.vercel.app/?text=Hello",
      "score": 169,
      "by": "zikero",
      "time": 1758161925,
      "descendants": 62,
      "type": "story",
      "created_at": "2025-09-17T16:18:45"
    },
    {
      "id": 45274277,
      "title": "Apple Photos app corrupts images",
      "url": "https://tenderlovemaking.com/2025/09/17/apple-photos-app-corrupts-images/",
      "score": 1084,
      "by": "pattyj",
      "time": 1758107264,
      "descendants": 388,
      "type": "story",
      "created_at": "2025-09-17T01:07:44"
    },
    {
      "id": 45251111,
      "title": "Orange Pi RV2 $40 RISC-V SBC: Friendly Gateway to IoT and AI Projects",
      "url": "https://riscv.org/ecosystem-news/2025/09/orange-pi-rv2-40-risc-v-sbc-friendly-gateway-to-iot-and-ai-projects/",
      "score": 35,
      "by": "warrenm",
      "time": 1757951162,
      "descendants": 27,
      "type": "story",
      "created_at": "2025-09-15T05:46:02"
    }
  ],
  "scraped_content": [
    {
      "url": "https://skyfall.dev/posts/slack",
      "title": "Slack has raised our charges by $195k per year",
      "content": "Slack is extorting us with a $195k/yr bill increase\nAn open letter, or something\nSeptember 18th 2025\nFor nearly 11 years, Hack Club - a nonprofit that provides coding education and community to teenagers worldwide - has used Slack as the tool for communication. We weren’t freeloaders. A few years ago, when Slack transitioned us from their free nonprofit plan to a $5,000/year arrangement, we happily paid. It was reasonable, and we valued the service they provided to our community.\nHowever, two days ago, Slack reached out to us and said that if we don’t agree to pay an extra $50k this week and $200k a year, they’ll deactivate our Slack workspace and delete all of our message history.\nOne could argue that Slack is free to stop providing us the nonprofit offer at any time, but in my opinion, a six month grace period is the bare minimum for a massive hike like this, if not more. Essentially, Salesforce (a $230 billion company) is strong-arming a small nonprofit for teens, by providing less than a week to pony up a pretty massive sum of money, or risk cutting off all our communications. That’s absurd.\nThe impact\nThe small amount of notice has also been catastrophic for the programs that we run. Dozens of our staff and volunteers are now scrambling to update systems, rebuild integrations and migrate years of institutional knowledge. The opportunity cost of this forced migration is simply staggering.\nAnyway, we’re moving to Mattermost. This experience has taught us that owning your data is incredibly important, and if you’re a small business especially, then I’d advise you move away too.\nThis post was rushed out because, well, this has been a shock! If you’d like any additional details then feel free to send me an email.",
      "author": null,
      "published_date": null,
      "meta_description": "An open letter, or something",
      "word_count": 299,
      "scraping_method": "beautifulsoup"
    },
    {
      "url": "https://webassembly.org/news/2025-09-17-wasm-3.0/",
      "title": "WASM 3.0 Completed",
      "content": "Three years ago, version 2.0 of the Wasm standard was (essentially) finished, which brought a number of new features, such as vector instructions, bulk memory operations, multiple return values, and simple reference types.\n\nIn the meantime, the Wasm W3C Community Group and Working Group have not been lazy. Today, we are happy to announce the release of Wasm 3.0 as the new “live” standard.\n\nThis is a substantially larger update: several big features, some of which have been in the making for six or eight years, finally made it over the finishing line.\n• 64-bit address space. Memories and tables can now be declared to use as their address type instead of just . That expands the available address space of Wasm applications from 4 gigabytes to (theoretically) 16 exabytes, to the extent that physical hardware allows. While the web will necessarily keep enforcing certain limits — on the web, a 64-bit memory is limited to 16 gigabytes — the new flexibility is especially interesting for non-web ecosystems using Wasm, as they can support much, much larger applications and data sets now.\n• Multiple memories. Contrary to popular belief, Wasm applications were always able to use multiple memory objects — and hence multiple address spaces — simultaneously. However, previously that was only possible by declaring and accessing each of them in separate modules. This gap has been closed, a single module can now declare (define or import) multiple memories and directly access them, including directly copying data between them. This finally allows tools like wasm-merge, which perform “static linking” on two or more Wasm modules by merging them into one, to work for all Wasm modules. It also paves the way for new uses of separate address spaces, e.g., for security (separating private data), for buffering, or for instrumentation.\n• Garbage collection. In addition to expanding the capabilities of raw linear memories, Wasm also adds support for a new (and separate) form of storage that is automatically managed by the Wasm runtime via a garbage collector. Staying true to the spirit of Wasm as a low-level language, Wasm GC is low-level as well: a compiler targeting Wasm can declare the memory layout of its runtime data structures in terms of struct and array types, plus unboxed tagged integers, whose allocation and lifetime is then handled by Wasm. But that’s it. Everything else, such as engineering suitable representations for source-language values, including implementation details like method tables, remains the responsibility of compilers targeting Wasm. There are no built-in object systems, nor closures or other higher-level constructs — which would inevitably be heavily biased towards specific languages. Instead, Wasm only provides the basic building blocks for representing such constructs and focuses purely on the memory management aspect.\n• Typed references. The GC extension is built upon a substantial extension to the Wasm type system, which now supports much richer forms of references. Reference types can now describe the exact shape of the referenced heap value, avoiding additional runtime checks that would otherwise be needed to ensure safety. This more expressive typing mechanism, including subtyping and type recursion, is also available for function references, making it possible to perform safe indirect function calls without any runtime type or bounds check, through the new instruction.\n• Tail calls. Tail calls are a variant of function calls that immediately exit the current function, and thereby avoid taking up additional stack space. Tail calls are an important mechanism that is used in various language implementations both in user-visible ways (e.g., in functional languages) and for internal techniques (e.g., to implement stubs). Wasm tail calls are fully general and work for callees both selected statically (by function index) and dynamically (by reference or table).\n• Exception handling. Exceptions provide a way to locally abort execution, and are a common feature in modern programming languages. Previously, there was no efficient way to compile exception handling to Wasm, and existing compilers typically resorted to convoluted ways of implementing them by escaping to the host language, e.g., JavaScript. This was neither portable nor efficient. Wasm 3.0 hence provides native exception handling within Wasm. Exceptions are defined by declaring exception tags with associated payload data. As one would expect, an exception can be thrown, and selectively be caught by a surrounding handler, based on its tag. Exception handlers are a new form of block instruction that includes a dispatch list of tag/label pairs or catch-all labels to define where to jump when an exception occurs.\n• Relaxed vector instructions. Wasm 2.0 added a large set of vector (SIMD) instructions, but due to differences in hardware, some of these instructions have to do extra work on some platforms to achieve the specified semantics. In order to squeeze out maximum performance, Wasm 3.0 introduces “relaxed” variants of these instructions that are allowed to have implementation-dependent behavior in certain edge cases. This behavior must be selected from a pre-specified set of legal choices.\n• Deterministic profile. To make up for the added semantic fuzziness of relaxed vector instructions, and in order to support settings that demand or need deterministic execution semantics (such as blockchains, or replayable systems), the Wasm standard now specifies a deterministic default behavior for every instruction with otherwise non-deterministic results — currently, this includes floating-point operators and their generated NaN values and the aforementioned relaxed vector instructions. Between platforms choosing to implement this deterministic execution profile, Wasm thereby is fully deterministic, reproducible, and portable.\n• Custom annotation syntax. Finally, the Wasm text format has been enriched with generic syntax for placing annotations in Wasm source code. Analogous to custom sections in the binary format, these annotations are not assigned any meaning by the Wasm standard itself, and can be chosen to be ignored by implementations. However, they provide a way to represent the information stored in custom sections in human-readable and writable form, and concrete annotations can be specified by downstream standards.\n\nIn addition to these core features, embeddings of Wasm into JavaScript benefit from a new extension to the JS API:\n• JS string builtins. JavaScript string values can already be passed to Wasm as externrefs. Functions from this new primitive library can be imported into a Wasm module to directly access and manipulate such external string values inside Wasm.\n\nWith these new features, Wasm has much better support for compiling high-level programming languages. Enabled by this, we have seen various new languages popping up to target Wasm, such as Java, OCaml, Scala, Kotlin, Scheme, or Dart, all of which use the new GC feature.\n\nOn top of all these goodies, Wasm 3.0 also is the first version of the standard that has been produced with the new SpecTec tool chain. We believe that this makes for an even more reliable specification.\n\nWasm 3.0 is already shipping in most major web browsers, and support in stand-alone engines like Wasmtime is on track to completion as well. The Wasm feature status page tracks support across engines.",
      "author": null,
      "published_date": null,
      "meta_description": "",
      "word_count": 1155,
      "scraping_method": "goose3"
    },
    {
      "url": "https://tenderlovemaking.com/2025/09/17/apple-photos-app-corrupts-images/",
      "title": "Apple Photos app corrupts images",
      "content": "Apple Photos App Corrupts Images\nSep 17, 2025 @\n8:59 am\nThe Apple Photos app sometimes corrupts images when importing from my camera.\nI just wanted to make a blog post about it in case anyone else runs into the problem.\nI’ve seen other references to this online, but most of the people gave up trying to fix it, and none of them went as far as I did to debug the issue.\nI’ll try to describe the problem, and the things I’ve tried to do to fix it.\nBut also note that I’ve (sort of) given up on the Photos app too.\nSince I can’t trust it to import photos from my camera, I switched to a different workflow.\nHere is a screenshot of a corrupted image in the Photos app:\nHow I used to import images\nI’ve got an OM System OM-1 camera.\nI used to shoot in RAW + jpg, then when I would import to Photos app, I would check the “delete photos after import” checkbox in order to empty the SD card.\nTurns out “delete after import” was a huge mistake.\nGetting corrupted images\nI’m pretty sure I’d been getting corrupted images for a while, but it would only be 1 or 2 images out of thousands, so I thought nothing of it (it was probably my fault anyway, right?)\nBut the problem really got me upset when last year I went to a family member’s wedding and took tons of photos.\nApple Photos combines RAW + jpg photos so you don’t have a bunch of duplicates, and when you view the images in the photos app, it just shows you the jpg version by default.\nAfter I imported all of the wedding photos I noticed some of them were corrupted.\nUpon closer inspection, I found that it sometimes had corrupted the jpg, sometimes corrupted the RAW file, and sometimes both.\nSince I had been checking the “delete after import” box, I didn’t know if the images on the SD card were corrupted before importing or not.\nAfter all, the files had been deleted so there was no way to check.\nI estimate I completely lost about 30% of the images I took that day.\nLosing so many photos really rattled me, but I wanted to figure out the problem so I didn’t lose images in the future.\nNarrowing down the problem\nI was worried this was somehow a hardware problem.\nCopying files seems so basic, I didn’t think there was any way a massively deployed app like Photos could fuck it up (especially since its main job is managing photo files).\nSo, to narrow down the issue I changed out all of the hardware.\nHere are all the things I did:\nSwitched USB-C cables\nBought a new SD card direct from the manufacturer (to eliminate the possibility of buying a bootleg SD card)\nSwitched to only shooting in RAW (if importing messes up 30% of my images, but I cut the number of images I import by half, then that should be fewer corrupted images right? lol)\nBought a new laptop\nBought a new camera: the OM System OM-1 MKii\nI did each of these steps over time, as to only change one variable at a time, and still the image corruption persisted.\nI didn’t really want to buy a new camera, the MKii is not really a big improvement over the OM-1, but we had a family trip coming up and the idea that pressing the shutter button on the camera might not actually record the image didn’t sit well with me.\nFinally a smoking gun\nSince I had replaced literally all of the hardware involved, I knew it must be a software problem.\nI stopped checking the “delete after import” button, and started reviewing all of the photos after import.\nAfter verifying none of them were corrupt, then I would format the SD card.\nI did this for months without finding any corrupt files.\nAt this point I figured it was somehow a race condition or something when copying the photo files and deleting them at the same time.\nHowever, after I got home from RailsConf and imported my photos, I found one corrupt image (the one above).\nI was able to verify that the image was not corrupt on the SD card, so the camera was working fine (meaning I probably didn’t need to buy a new camera body at all).\nI tried deleting the corrupt file and re-importing the original to see if it was something about that particular image, but it re-imported just fine.\nIn other words, it seems like the Photos app will corrupt files randomly.\nI don’t know if this is a problem that is specific to OM System cameras, and I’m not particularly interested in investing in a new camera system just to find out.\nIf I compare the corrupted image with the non-corrupted image, the file sizes are exactly the same, but the bytes are different:\nChecksums:\naaron@tc ~/Downloads> md5sum P7110136-from-camera.ORF Exports/P7110136.ORF\n17ce895fd809a43bad1fe8832c811848\nP7110136-from-camera.ORF\n828a33005f6b71aea16d9c2f2991a997\nExports/P7110136.ORF\nFile sizes:\naaron@tc ~/Downloads> ls -al P7110136-from-camera.ORF Exports/P7110136.ORF\n-rw-------@ 1 aaron\nstaff\n18673943 Jul 12 04:38 Exports/P7110136.ORF\n-rwx------\n1 aaron\nstaff\n18673943 Jul 17 09:29 P7110136-from-camera.ORF*\nThe P7110136-from-camera.ORF is the non-corrupted file, and Exports/P7110136.ORF is the corrupted file from Photos app.\nHere’s a screenshot of the preview of the non-corrupted photo:\nHere is the binary diff between the files.\nI ran both files through xxd then diffed them.\nMy new workflow\nI’m not going to put any more effort into debugging this problem, but I wanted to blog about it in case anyone else is seeing the issue.\nI take a lot of photos, and to be frank, most of them are not very good.\nI don’t want to look through a bunch of bad photos every time I look at my library, so culling photos is important.\nCulling photos in the Photos app is way too cumbersome, so I’ve switched to using Darktable.\nMy current process is:\nImport images to Darktable\nDelete the ones I don’t like\nProcess ones I do like\nExport both the jpg and the original raw file\nImport those to the Photos app so they’re easy to view and share\nPeriodically format my SD card\nI’ve not seen any file corruption when importing to Darktable, so I am convinced this is a problem with the Photos app.\nBut now, since all of my images land in Darktable before making their way to the Photos app, I don’t really care anymore.\nThe bad news is that I’ve spent a lot of time and money trying to debug this.\nI guess the good news is that now I have redundant hardware!",
      "author": null,
      "published_date": null,
      "meta_description": null,
      "word_count": 1115,
      "scraping_method": "beautifulsoup"
    },
    {
      "url": "https://riscv.org/ecosystem-news/2025/09/orange-pi-rv2-40-risc-v-sbc-friendly-gateway-to-iot-and-ai-projects/",
      "title": "Orange Pi RV2 $40 RISC-V SBC: Friendly Gateway to IoT and AI Projects",
      "content": "What if you could explore the innovative world of RISC-V computing without breaking the bank? The Orange Pi RV2 promises exactly that, a budget-friendly gateway into an architecture that’s reshaping the future of processors. With its 8-core RISC-V processor, a host of connectivity options, and a price tag starting at just $40, this single-board computer (SBC) is designed to appeal to developers, hobbyists, and industry professionals alike. But here’s the catch: while it excels in specialized tasks like IoT and lightweight AI, it’s not built to replace your desktop PC. This duality makes the RV2 both intriguing and polarizing, raising the question: can affordability and innovation truly coexist in the world of SBCs?\n\nIn this overview, Interfacing Linux explores what makes the Orange Pi RV2 a standout in its niche, from its energy-efficient design to its versatile hardware capabilities. You’ll discover how its dual NVMe slots, GPIO interface, and AI-optimized processor open doors to industrial automation and IoT projects, while also uncovering its limitations in software support and desktop performance. Whether you’re a tinkerer eager to experiment with RISC-V or a professional seeking a cost-effective solution for specialized applications, the RV2 offers plenty to unpack. By the end, you might just find yourself rethinking what’s possible with a $40 SBC.",
      "author": null,
      "published_date": null,
      "meta_description": "",
      "word_count": 210,
      "scraping_method": "goose3"
    }
  ],
  "audio_files": [
    "output/audio/hackercast_20250917_215424.mp3"
  ],
  "stats": {
    "stories_fetched": 6,
    "articles_scraped": 4,
    "total_words": 2779,
    "audio_files_generated": 1
  }
}