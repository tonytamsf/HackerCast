Welcome to HackerCast, your daily digest of the top stories from Hacker News. Today is September 16, 2025, and we have 5 fascinating stories to share with you.

Story 1: GNU Midnight Commander
GNU Midnight Commander (or ) is a visual, dual-pane file manager. It is released under the GNU General Public License and therefore qualifies as Free Software.

Midnight Commander is a feature-rich, full-screen, text-mode application that allows you to copy, move, and delete files and entire directory trees, search for files, and execute commands in the subshell. Internal viewer, editor and diff viewer are included.

uses versatile text interface libraries such as ncurses or S-Lang, which allows it to work on a regular console, inside an X Window terminal, over connections, and in all kinds of remote shells.

The easiest way to install is to use your system package manager:

Our source releases are kindly mirrored by OSU OSL. Our canonical repository is hosted on GitHub. See the Source code page for details.

The primary way to learn about is to use the context-sensitive online help available via .

We also have extensive manual pages, which are the primary source of official documentation:

Midnight Commander supports theming! Check out the skins that come with the distribution or develop your own:
• For support, see the Communication page.
• To contribute to , proceed to the "Development" section.
• Release notes for the development version are collected on the wiki.

Next up...

Story 2: Notion API importer, with Databases to Bases conversion bounty
Currently Importer supports Notion imports via the HTML export #14. This new importer would use the Notion API and download files progressively. This would also add support for Databases to Bases conversion. See #415

See the Contribution guidelines for how to claim this bounty.

Please only apply if you have taken time to explore the Importer codebase, as well as the Notion API. Provide detail about how you would approach solving it within the constraints of this Obsidian plugin.
• Uses Notion API (integration token) incorporating changes from new data source object introduced 2025-09.
• Support for images and attachments. Embed links converted to Markdown format and placed in the user's defined attachment location (Settings → File & links)
• Provide working test cases, ideally a reproducible data import that can be used on Notion. Alternatively a test account you can share with us via DM.

Some exploration is required before implementation because Databases and Bases work a bit differently. Notion's Databases start out as empty, whereas a Base starts out with all of the user's files, then narrows down using filters.
• Determine for importing files, and the bases/views
• Determine what can be imported: views, columns, groups, summaries, formulas, etc.

Next up...

Story 3: The Asus Gaming Laptop ACPI Firmware Bug: A Deep Technical Investigation
You own a high-end ASUS ROG laptop perhaps a Strix, Scar, or Zephyrus. It's specifications are impressive: an RTX 30/40 series GPU, a top-tier Intel processor, and plenty of RAM. Yet, it stutters during basic tasks like watching a YouTube video, audio crackles and pops on Discord calls, the mouse cursor freezes for a split second, just long enough to be infuriating.

You've likely tried all the conventional fixes:
• Even installing Linux, only to find the problem persists.

If none of that worked, it's because the issue isn't with the operating system or a driver. The problem is far deeper, embedded in the machine's firmware, the BIOS.

The first tool in any performance investigator's toolkit for these symptoms is LatencyMon. It acts as a canary in the coal mine for system-wide latency issues. On an affected ASUS Zephyrus M16, the results are immediate and damning:

The data clearly implicates . However, the per-CPU data reveals a more specific pattern:

CPU 0 is taking the brunt of the impact, spending over 90 seconds processing interrupts while other cores remain largely unaffected. This isn't a failure of load balancing; it's a process locked to a single core.

A similar test on a Scar 15 from 2022 shows the exact same culprit: high DPC latency originating from .

It's easy to blame a Windows driver, but is not a typical driver. It primarily functions as an interpreter for ACPI Machine Language (AML), the code provided by the laptop's firmware (BIOS). If is slow, it's because the firmware is feeding it inefficient or flawed AML code to execute. These slowdowns are often triggered by General Purpose Events (GPEs) and traffic from the Embedded Controller (EC). To find the true source, we must dig deeper.

To understand what is doing during these latency spikes, we can use Event Tracing for Windows (ETW) to capture detailed logs from the ACPI providers.

Analyzing the resulting trace file in the Windows Performance Analyzer reveals a crucial insight. The spikes aren't random; they are periodic, occurring like clockwork every 30 to 60 seconds.

Random interruptions often suggest hardware faults or thermal throttling. A perfectly repeating pattern points to a systemic issue, a timer or a scheduled event baked into the system's logic.

The first event, , is an interrupt handler that takes 13.6 milliseconds to execute. For a high-priority interrupt, this is an eternity and is catastrophic for real-time system performance.

Deeper in the trace, another bizarre behavior emerges; the system repeatedly attempts to power the discrete GPU on and off, even when it's supposed to be permanently active.

This power cycling is nonsensical because the laptop is configured for a scenario where it is impossible: The system is in Ultimate Mode (via a MUX switch) with an external display connected.
• The discrete NVIDIA GPU (dGPU) is the only active graphics processor.
• The integrated Intel GPU (iGPU) is completely powered down and bypassed.
• The dGPU is wired directly to the internal and external displays.
• There is no mechanism for switching between GPUs.

Yet, the firmware is relentlessly trying to power cycle the dGPU every 15-30 seconds. The dGPU in mux mode isn't just "preferred" - it's the ONLY path to the display. There's no fallback, and no alternative. When the firmware sends (power off), it's attempting something architecturally impossible.

Most of the time, hardware sanity checks refuse these nonsensical commands, but even failed attempts introduce latency spikes causing audio dropouts, input lag, and accumulating performance degradation. Games freeze mid-session, videos buffer indefinitely, system responsiveness deteriorates until restart.

Sometimes, under specific thermal conditions or race conditions, the power-down actually succeeds. When the firmware manages to power down the GPU that's driving the display, the sequence is predictable and catastrophic:
• GPU enters impossible state - firmware insists OFF, Windows needs ON

The crash dump confirms the thread is stuck in , waiting for the NVIDIA driver to respond. It can't because it's caught between a confused power state, windows wanting to turn on the GPU while the firmware is arming the GPU cut off.

GPEs are the firmware's mechanism for signaling hardware events to the operating system. They are essentially hardware interrupts that trigger the execution of ACPI code. The trace data points squarely at as the source of our latency.

A closer look at the timing reveals a consistent and problematic pattern:

Every single time the lengthy event fires, it triggers the exact same sequence of ACPI method calls.
• Shortly thereafter, the firmware attempts to change the GPU's power state.
• The system runs normally for about 30-60 seconds.

To analyze the code responsible for this behavior, we must extract and decompile the ACPI tables provided by the BIOS to the operating system.

This decompiled ASL provides a direct view into the firmware's executable logic. It is a precise representation of the exact instructions that the ACPI.sys driver is fed by the firmware and executes at the highest privilege level within the Windows kernel. Any logical flaws found in this code are the direct cause of the system's behavior.

Searching the decompiled file, we find the definition for our problematic GPE handler:

This code is simple: when the interrupt occurs, it calls a single method, . The "L" prefix in signifies that this is a level-triggered interrupt, meaning it will continue to fire as long as the underlying hardware condition is active. This is a critical detail.

Following the call to , we uncover a deeply flawed implementation that is the direct cause of the system-wide stuttering.

This short block of code violates several fundamental principles of firmware and kernel programming.

An interrupt handler runs at a very high priority to service hardware requests quickly. The function completely halts the execution of the CPU core it is running on (CPU 0 in this case). While CPU 0 is sleeping, it cannot:
• Allow the kernel to schedule other threads.

Wtf 2: Time-Sliced Interrupt Processing The entire loop is designed to run for an extended period, processing events in batches. It's effectively a poorly designed task scheduler running inside an interrupt handler, capable of holding a CPU core hostage for potentially seconds at a time.

This logic ensures that even if the Embedded Controller's event queue is empty, the code will create a new, artificial event. This guarantees that another interrupt will fire shortly after, creating the perfectly periodic pattern of ACPI spikes observed in the traces.

The LEVN() method takes an event and routes it:

The LGPA() method is a giant switch statement handling different events:

This shows a direct link: a GPE fires, and the dispatch logic calls functions related to battery polling and GPU notifications.

The method, called by multiple event types, is responsible for polling the battery and AC adapter status.

Which we can see here:

Each of these operations requires communication with the Embedded Controller, adding to the workload inside the already-stalled interrupt handler.

The method sends notifications to the GPU driver.

These notifications ( , , etc.) are hardware-specific signals that tell the NVIDIA driver to re-evaluate its power state, which is what triggers the futile power-cycling sequence seen in the traces.

Here's where a simple but catastrophic oversight in the firmware's logic causes system-wide failure. High-end ASUS gaming laptops feature a MUX (Multiplexer) switch, a piece of hardware that lets the user choose between two distinct graphics modes:
• Optimus Mode: The power-saving default. The integrated Intel GPU (iGPU) is physically connected to the display. The powerful NVIDIA GPU (dGPU) only renders demanding applications when needed, passing finished frames to the iGPU to be drawn on screen.
• Ultimate/Mux Mode: The high-performance mode. The MUX switch physically rewires the display connections, bypassing the iGPU entirely and wiring the NVIDIA dGPU directly to the screen. In this mode, the dGPU is not optional; it is the only graphics processor capable of outputting an image.

Any firmware managing this hardware must be aware of which mode the system is in. Sending a command intended for one GPU to the other is futile and, in some cases, dangerous. Deep within the ACPI code, a hardware status flag named is used to track this state. To understand the flaw, we first need to decipher what means, and the firmware itself gives us the key.

For screen brightness to work, the command must be sent to the GPU that is physically controlling the display backlight. A command sent to the wrong GPU will simply do nothing. Therefore, the brightness control method ( ) must be aware of the MUX switch state to function at all. It is the firmware's own Rosetta Stone.

The logic here is flawless and revealing. The code uses the flag to make a binary decision. If is , it sends the command to the NVIDIA GPU. If not, it sends it to the Intel GPU. The firmware itself, through this correct implementation, provides the undeniable definition: means the system is in Ultimate/Mux Mode.

This perfect, platform-aware logic is completely abandoned in the critical code paths responsible for power management. The method, which is called by the stutter-inducing interrupt, dispatches power-related commands to the GPU without ever checking the MUX mode.

This is the bug. The firmware, despite proving it knows how to check the MUX state, forgets to do so here. It blindly sends a power-management notification to the NVIDIA driver, instructing it to change power states. In MUX mode, this command is nonsensical it's asking the driver to power down the only GPU that is keeping the screen on. This triggers the futile power-cycling, the massive latency spikes, and the system instability.

This is not a single typo. A second, parallel power management system in the firmware exhibits the exact same flaw. The Platform Extension Plug-in Device ( ) is used by Windows to manage system-wide power states, such as turning off displays during modern standby.

Once again, the firmware prepares to cut power to the discrete GPU without first checking if it's the only GPU driving the displays. This demonstrates that the Mux Mode Confusion is a systemic design flaw. The firmware is internally inconsistent, leading it to issue self-destructive commands that try to cripple the system.

Traces from multiple ASUS gaming laptop models confirm this is not an isolated issue.

Microsoft has a built-in "smooth video" check. It plays HD video in full screen and watches for hiccups. If the PC drops frames, crackles, or any driver pauses for more than a few milliseconds, it fails. That’s Microsoft’s baseline for what "smooth" should look like.

Why it matters here:

ASUS firmware is causing millisecond-long pauses. Those pauses are exactly the kind that make this test fail i.e., the same stutters and audio pops regular users notice on YouTube/Netflix and games; this firmware violates fundemental standards.

Despite being different models, all affected systems exhibit the same core flaws:
• handlers take milliseconds to execute instead of microseconds.
• The firmware attempts to power cycle the GPU while in a fixed MUX mode.
• The entire process is driven by a periodic, timer-like trigger.

This bug is a cascade of firmware design failures.

The firmware's method treats a high-priority interrupt handler like a standard application thread, which is fundamentally incorrect.

What It Should Be:

The firmware artificially re-arms the interrupt, creating an endless loop of GPEs instead of clearing the source and waiting for the next legitimate hardware event. This transforms a hardware notification system into a disruptive, periodic timer.

The code that sends GPU power notifications does not check if the system is in MUX mode, a critical state check that is correctly performed in other parts of the firmware. This demonstrates inconsistency and a lack of quality control.

This issue is not new or isolated. User reports documenting identical symptoms with high ACPI.sys DPC latency, periodic stuttering, and audio crackling have been accumulating since at least 2021 across ASUS's entire gaming laptop lineup.

August 2021: The First Major Reports

 The earliest documented cases appear on the official ASUS ROG forums. A G15 Advantage Edition (G513QY) owner reports "severe DPC latency from ACPI.sys" with audio dropouts occurring under any load condition. The thread, last edited in March 2024, shows the issue remains unresolved after nearly three years.

Reddit users simultaneously report identical ACPI.sys latency problems alongside NVIDIA driver issues; the exact symptoms described in this investigation.

2021-2023: Spreading Across Models

 Throughout this period, the issue proliferates across ASUS's gaming lineup:

2023-2024: The Problem Persists in New Models

 Even the latest generations aren't immune:
• Measured Proof: GPE handlers are measured blocking a CPU core for over 13 milliseconds.
• Code Proof: The decompiled firmware explicitly contains calls within an interrupt handler.
• Logical Proof: The code lacks critical checks for the laptop's hardware state (MUX mode).
• Systemic Proof: The issue is reproducible across different models and BIOS versions.

Until a fix is implemented, millions of buyers of Asus laptops from approx. 2021 to present day are facing stutters on the simplest of tasks, such as watching YouTube, for the simple mistake of using a sleep call inside of an inefficient interrupt handler and not checking the GPU environment properly.

The code is there. The traces prove it. ASUS must fix its firmware.

Investigation conducted using the Windows Performance Toolkit, ACPI table extraction tools, and Intel ACPI Component Architecture utilities. All code excerpts are from official ASUS firmware. Traces were captured on multiple affected systems, all showing consistent behavior.

Next up...

Story 4: Shai-Hulud malware attack: Tinycolor and over 40 NPM packages compromised
Application Security/Security NewsAI + a16z Podcast: Vibe Coding, Security Risks, and the Path to ProgressSocket CEO Feross Aboukhadijeh and a16z partner Joel de la Garza discuss vibe coding, AI-driven software development, and how the rise of LLMs, despite their risks, still points toward a more secure and innovative future.By Sarah Gooding  -  Jul 25, 2025

Next up...

Story 5: I just want an 80×25 console, but that's no longer possible
Somehow along the way, a feature that I’ve had across DOS, OS/2, FreeBSD, and Linux — and has been present on PCs for more than 40 years — is gone.
That feature, of course, is the 80×25 text console.
Linux has, for awhile now, rendered its text console using graphic modes.
You can read all about it here.
This has been necessary because only PCs really had the 80×25 text mode (Raspberry Pis, for instance, never did), and even they don’t have it when booted with UEFI.
I’ve lately been annoyed that:
The console is a different size on every screen — both in terms of size of letters and the dimensions of it
If a given machine has more than one display, one or both of them will have parts of the console chopped off
My system seems to run with three different resolutions or fonts at different points of the boot process.
One during the initrd, and two different ones during the remaining boot.
And, I wanted to run some software on the console that was designed with 80×25 in mind.
And I’d like to be able to plug in an old VGA monitor and have it just work if I want to do that.
That shouldn’t be so hard, right?
Well, the old vga= option that you are used to doesn’t work when you booted from UEFI or on non-x86 platforms.
Most of the tricks you see online for changing resolutions, etc., are no longer relevant.
And things like setting a resolution with GRUB are useless for systems that don’t use GRUB (including ARM).
VGA text mode uses 8×16 glyphs in 9×16 cells, where the pixels are non-square, giving a native resolution of 720×400 (which historically ran at 70Hz), which should have streched pixels to make a 4:3 image.
While it is possible to select a console font, and 8×16 fonts are present and supported in Linux, it appears to be impossible to have a standard way to set 720×400 so that they present in a reasonable size, at the correct aspect ratio, with 80×25.
Tricks like nomodeset no longer work on UEFI or ARM systems.
It’s possible that kmscon or something like it may help, but I’m not even certain of that (video=eDP1:720×400 produced an error saying that 720×400 wasn’t a supported mode, so I’m unsure kmscon would be any better.)
Not that it matters; all the kmscon options to select a font or zoom are broken, and it doesn’t offer mode selection anyhow.
I think I’m going to have to track down an old machine.
Sigh.

That wraps up today's HackerCast. Thank you for listening, and we'll see you tomorrow with more stories from the world of technology.